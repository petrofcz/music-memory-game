
/**
 @constructor
 @abstract
 */
function BaseTask() {
    if (this.constructor === BaseTask) { throw new Error("Can't instantiate abstract class!"); }

}

/**
 * Returns available rendering methods
 * @abstract
 * @return array
 */
BaseTask.getAvailableRMs = function() { throw new Error("Abstract method!"); };

/**
 * Returns number of records generated by the task (ie. # of scales,..)
 * @abstract
 * @return number
 */
BaseTask.getRecordCount = function() { throw new Error('Abstract method!'); };

/**
 * Renders the task to the given element using method specified (by TaskRenderingMethods)
 * @param method TaskRenderingMethods
 * @param element HTML element to be the content rendered in
 * @param finishedCallback callback that is called after rendering is finished
 * @param ... OTHER PARAMS POSSIBLE
 */
BaseTask.prototype.render = function(method, element, finishedCallback) {
    var property = 'render' + method.capitalizeFirstLetter();
    var args = Array.prototype.slice.call(arguments);
    args.splice(0, 1);
    if(this.hasOwnProperty(property)) {
        this[property].apply(this, args);
    } else {
        throw new Error('Given rendering method not implemented');
    }
};
